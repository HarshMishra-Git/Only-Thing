import { FastifyRequest, FastifyReply } from 'fastify';
import csrf from '@fastify/csrf-protection';
import { FastifyInstance } from 'fastify';
import { logger } from '../lib/logger';

/**
 * CSRF Protection Configuration
 */
export const csrfConfig = {
  // Use session-based CSRF tokens
  sessionPlugin: '@fastify/secure-session',
  
  // Cookie options for CSRF token
  cookieOpts: {
    httpOnly: true,
    sameSite: 'strict' as const,
    secure: process.env.NODE_ENV === 'production',
    signed: true,
    path: '/',
  },

  // Get CSRF secret from environment or generate
  getSecret: () => {
    return process.env.CSRF_SECRET || 'your-csrf-secret-change-in-production';
  },
};

/**
 * Register CSRF protection plugin
 */
export async function registerCsrfProtection(server: FastifyInstance) {
  await server.register(csrf, csrfConfig);
  logger.info('CSRF protection enabled');
}

/**
 * CSRF middleware - validates CSRF token on state-changing requests
 */
export async function csrfMiddleware(
  request: FastifyRequest,
  reply: FastifyReply
) {
  // Skip CSRF for safe methods
  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];
  if (safeMethods.includes(request.method)) {
    return;
  }

  // Skip CSRF for API routes using JWT (they use bearer tokens instead)
  const isApiRoute = request.url.startsWith('/api/');
  const hasAuthHeader = request.headers.authorization?.startsWith('Bearer ');
  
  if (isApiRoute && hasAuthHeader) {
    return; // JWT provides its own protection
  }

  // For form submissions and cookie-based auth, require CSRF token
  try {
    // CSRF token should be in header or body
    const token = 
      request.headers['x-csrf-token'] ||
      request.headers['csrf-token'] ||
      (request.body as any)?.csrfToken ||
      (request.body as any)?._csrf;

    if (!token) {
      logger.warn({
        event: 'csrf_token_missing',
        url: request.url,
        method: request.method,
        ip: request.ip,
      }, 'CSRF token missing');

      return reply.code(403).send({
        statusCode: 403,
        error: 'Forbidden',
        message: 'CSRF token missing',
      });
    }

    // Validate token (implementation depends on your CSRF library)
    // This is handled by @fastify/csrf-protection automatically
    
  } catch (error) {
    logger.error({
      err: error,
      event: 'csrf_validation_failed',
      url: request.url,
    }, 'CSRF validation error');

    return reply.code(403).send({
      statusCode: 403,
      error: 'Forbidden',
      message: 'Invalid CSRF token',
    });
  }
}

/**
 * Generate CSRF token for response
 * Usage in routes: const token = await reply.generateCsrf()
 */
export function getCsrfToken(request: FastifyRequest, reply: FastifyReply) {
  // Generated by @fastify/csrf-protection
  return (reply as any).generateCsrf?.() || '';
}

/**
 * Decorator to skip CSRF protection for specific routes
 */
export const skipCsrf = {
  config: {
    csrf: false,
  },
};

/**
 * CSRF token provider for frontend
 */
export async function csrfTokenHandler(
  request: FastifyRequest,
  reply: FastifyReply
) {
  try {
    const token = await getCsrfToken(request, reply);
    
    return reply.send({
      csrfToken: token,
    });
  } catch (error) {
    logger.error({ err: error }, 'Failed to generate CSRF token');
    
    return reply.code(500).send({
      statusCode: 500,
      error: 'Internal Server Error',
      message: 'Failed to generate CSRF token',
    });
  }
}

export default registerCsrfProtection;
